#pragma once

#include <iostream>
using namespace std;

template <typename T>
class SentinelLinkedList
{
private:
    template <typename T>
    class Node
    {
    public:
        Node()
        {
            prev = nullptr;
            next = nullptr;
        }

        Node(T value)
        {
            data = value;
            prev = nullptr;
            next = nullptr;
        }

        T data;
        Node<T>* next;
        Node<T>* prev;
    };

private:
    Node<T>* NIL;
    int count;

public:
    SentinelLinkedList()
    {
        count = 0;
        operationCounter = 0;
        NIL = new SentinelLinkedList::Node<T>();
        NIL->next = NIL;
        NIL->prev = NIL;
    }

    int GetCount() { return count; };

    Node<T>* Find(T value);
    Node<T>* FindV2(T value);
    Node<T>* Successor(Node<T>* node);
    Node<T>* Predecessor(Node<T>* node);

    void PushBack(T value);
    T PopBack();

    void PushFront(T value);  // Nueva funci칩n
    T PopFront();             // Nueva funci칩n

    void Insert(T valueToInsert, Node<T>* previousNode);
    void Remove(T valueToRemove);

    int operationCounter;
};

// Remove
template<typename T>
void SentinelLinkedList<T>::Remove(T valueToRemove)
{
    Node<T>* currentNode = NIL->next;

    while (currentNode != NIL)
    {
        if (currentNode->data == valueToRemove)
        {
            currentNode->prev->next = currentNode->next;
            currentNode->next->prev = currentNode->prev;

            delete currentNode;
            count--;
            return;
        }
        else
        {
            currentNode = currentNode->next;
        }
    }
}

// Find
template<typename T>
typename SentinelLinkedList<T>::Node<T>* SentinelLinkedList<T>::Find(T value)
{
    Node<T>* currentNode = NIL->next;
    while (currentNode != NIL)
    {
        if (currentNode->data == value)
        {
            return currentNode;
        }
        currentNode = currentNode->next;
    }
    return nullptr;
}

// FindV2
template<typename T>
typename SentinelLinkedList<T>::Node<T>* SentinelLinkedList<T>::FindV2(T value)
{
    Node<T>* currentNode = NIL->next;
    while (currentNode != NIL)
    {
        if (currentNode->data == value)
        {
            return currentNode;
        }
        currentNode = currentNode->next;
    }
    return nullptr;
}

// Successor
template<typename T>
typename SentinelLinkedList<T>::Node<T>* SentinelLinkedList<T>::Successor(Node<T>* node)
{
    return node->next;
}

// Predecessor
template<typename T>
typename SentinelLinkedList<T>::Node<T>* SentinelLinkedList<T>::Predecessor(Node<T>* node)
{
    return node->prev;
}

// PushBack
template<typename T>
void SentinelLinkedList<T>::PushBack(T value)
{
    Node<T>* newNode = new Node<T>(value);
    newNode->next = NIL;
    NIL->prev->next = newNode;
    newNode->prev = NIL->prev;
    NIL->prev = newNode;
    count++;
}

// PopBack
template<typename T>
T SentinelLinkedList<T>::PopBack()
{
    if (count == 0)
    {
        cout << "Cuidado, est치s haciendo pop back cuando ya no hay elementos en esta lista ligada" << endl;
        return {};
    }

    Node<T>* penultimateNode = NIL->prev;
    NIL->prev = penultimateNode->prev;
    penultimateNode->prev->next = NIL;

    T data = penultimateNode->data;
    delete penultimateNode;
    penultimateNode = nullptr;
    count--;

    return data;
}

// PushFront
template<typename T>
void SentinelLinkedList<T>::PushFront(T value)
{
    Node<T>* newNode = new Node<T>(value);
    newNode->next = NIL->next;
    newNode->prev = NIL;
    NIL->next->prev = newNode;
    NIL->next = newNode;
    count++;
}

// PopFront
template<typename T>
T SentinelLinkedList<T>::PopFront()
{
    if (count == 0)
    {
        cout << "Cuidado, est치s haciendo pop front cuando ya no hay elementos en esta lista ligada" << endl;
        return {};
    }

    Node<T>* firstNode = NIL->next;
    T data = firstNode->data;
    NIL->next = firstNode->next;
    firstNode->next->prev = NIL;

    delete firstNode;
    firstNode = nullptr;
    count--;

    return data;
}

// Insert
template<typename T>
void SentinelLinkedList<T>::Insert(T valueToInsert, Node<T>* previousNode)
{
    Node<T>* newNode = new Node<T>(valueToInsert);
    newNode->next = previousNode->next;
    newNode->prev = previousNode;
    previousNode->next->prev = newNode;
    previousNode->next = newNode;
    count++;
}
